<!DOCTYPE html>
<html>
<head>
    <title>Wishlize Diagnostic</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #0f0; }
        .log { margin: 5px 0; padding: 5px; background: #2d2d44; border-radius: 4px; }
        .error { color: #f44; }
        .warn { color: #fa0; }
        .info { color: #0af; }
        h1 { color: #fff; }
        button { padding: 10px 20px; margin: 10px 5px; cursor: pointer; }
        #phase3-controls { margin: 12px 0; padding: 10px; background: #22223f; border-radius: 6px; }
        #phase3-controls input, #phase3-controls select { width: 100%; margin: 6px 0; padding: 8px; box-sizing: border-box; background: #0f1028; color: #c9ffe0; border: 1px solid #3d4a75; border-radius: 4px; }
        #phase3-presets { margin: 8px 0; }
        #phase3-presets button { padding: 8px 10px; font-size: 12px; }
        .phase3-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 10px; margin-top: 8px; }
        .phase3-panel { background: #1f233a; border: 1px solid #344a6f; border-radius: 6px; padding: 8px; }
        .phase3-panel h3 { margin: 0 0 8px 0; color: #fff; font-size: 14px; }
        .phase3-panel pre { margin: 0; white-space: pre-wrap; word-break: break-word; color: #9ce6ff; font-size: 12px; }
    </style>
</head>
<body>
    <h1>üîç Wishlize Diagnostic Tool</h1>
    <p>Open browser console (F12) to see detailed network interception logs</p>
    <div id="logs"></div>
    
    <script>
        const logs = document.getElementById('logs');
        
        function log(msg, type = 'info') {
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logs.appendChild(div);
        }
        
        // Intercept ALL fetch requests
        const originalFetch = window.fetch;
        window.fetch = function(...args) {
            const url = args[0];
            log(`Fetch: ${url}`, 'info');
            if (url.includes('null')) {
                log(`‚ö†Ô∏è NULL DETECTED in fetch: ${url}`, 'error');
                console.trace('Fetch with null');
            }
            return originalFetch.apply(this, args);
        };
        
        // Intercept ALL XMLHttpRequest
        const originalOpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, ...args) {
            log(`XHR: ${method} ${url}`, 'info');
            if (url.includes('null')) {
                log(`‚ö†Ô∏è NULL DETECTED in XHR: ${url}`, 'error');
                console.trace('XHR with null');
            }
            return originalOpen.call(this, method, url, ...args);
        };
        
        // Intercept image loads
        const originalImageSrc = Object.getOwnPropertyDescriptor(Image.prototype, 'src');
        Object.defineProperty(Image.prototype, 'src', {
            set: function(url) {
                log(`Image load: ${url}`, 'info');
                if (url && url.includes('null')) {
                    log(`‚ö†Ô∏è NULL DETECTED in image src: ${url}`, 'error');
                    console.trace('Image with null src');
                }
                return originalImageSrc.set.call(this, url);
            },
            get: originalImageSrc.get
        });
        
        // Monitor ALL script errors
        window.addEventListener('error', (e) => {
            log(`Script Error: ${e.message} at ${e.filename}:${e.lineno}`, 'error');
        });
        
        // Monitor unhandled promises
        window.addEventListener('unhandledrejection', (e) => {
            log(`Unhandled Promise: ${e.reason}`, 'error');
        });
        
        // Check for common extension signatures
        log('Checking for browser extensions...', 'info');
        setTimeout(() => {
            const scripts = document.querySelectorAll('script[src]');
            scripts.forEach(s => {
                if (s.src.includes('chrome-extension') || s.src.includes('moz-extension')) {
                    log(`Extension script detected: ${s.src}`, 'warn');
                }
            });
        }, 1000);
        
        log('Diagnostic active - intercepting all network requests...', 'info');
    </script>
    
    <!-- Load the actual widget to see what it does -->
    <h2>Test Widget Integration:</h2>
    <div id="wishlize-widget-container"></div>
    <img id="main-product-image" 
         src="assets/images/blazer.jpg" 
         alt="Test Product"
         data-wishlize-garment="https://wishlize-cdn.s3.ap-south-1.amazonaws.com/garments/blazer.jpg">

    <h2>Shadow Crawler Fixture:</h2>
    <div id="crawler-fixture"></div>

    <h2>Phase 3 Matching Engine Harness:</h2>
    <div id="phase3-controls">
        <label for="phase3-prompt">Prompt</label>
        <input id="phase3-prompt" type="text" value="Need a party look with a bold vibe" />
        <label for="phase3-audience">Audience Context</label>
        <select id="phase3-audience">
            <option value="">none</option>
            <option value="men">men</option>
            <option value="woman">woman</option>
        </select>
        <button id="phase3-run" type="button">Run Recommendation</button>
        <div id="phase3-presets">
            <button type="button" data-preset="Need a wedding look with a classic style" data-audience="woman">Wedding + Classic</button>
            <button type="button" data-preset="Office meeting outfit, clean and modern" data-audience="men">Business + Modern</button>
            <button type="button" data-preset="asdf qwer zzz" data-audience="">Vague Input</button>
        </div>
    </div>
    <div class="phase3-grid">
        <div class="phase3-panel">
            <h3>Intent</h3>
            <pre id="phase3-intent-output">{}</pre>
        </div>
        <div class="phase3-panel">
            <h3>Top 3</h3>
            <pre id="phase3-top3-output">[]</pre>
        </div>
        <div class="phase3-panel">
            <h3>Persona</h3>
            <pre id="phase3-persona-output">{}</pre>
        </div>
        <div class="phase3-panel">
            <h3>Debug</h3>
            <pre id="phase3-debug-output">{}</pre>
        </div>
    </div>

    <script src="assets/js/concierge/products.js"></script>
    <script src="assets/js/concierge/shadow-crawler.js"></script>
    <script src="assets/js/concierge/intent-parser.js"></script>
    <script src="assets/js/concierge/scoring.js"></script>
    <script src="assets/js/concierge/personas.js"></script>
    <script src="assets/js/concierge/matching-engine.js"></script>
    <script>
        const REQUIRED_TAXONOMIES = ['occasion', 'vibe', 'material'];

        function pretty(value) {
            return JSON.stringify(value, null, 2);
        }

        function validateConciergeCatalog() {
            const catalog = window.WishlizeProducts;
            const taxonomy = window.WishlizeProductTaxonomy || {};

            if (!Array.isArray(catalog)) {
                log('Catalog missing: window.WishlizeProducts is not an array', 'error');
                return { ok: false, catalog: [], taxonomy: {}, errors: ['catalog missing'] };
            }

            if (catalog.length < 15) {
                const message = `Catalog too small: found ${catalog.length}, expected at least 15`;
                log(message, 'error');
                return { ok: false, catalog, taxonomy, errors: [message] };
            }

            const seenIds = new Set();
            const allowedSets = {};
            for (const key of REQUIRED_TAXONOMIES) {
                const values = Array.isArray(taxonomy[key]) ? taxonomy[key] : [];
                allowedSets[key] = new Set(values);
            }

            const errors = [];

            catalog.forEach((product, index) => {
                const context = `index ${index}`;
                if (!product || typeof product !== 'object') {
                    errors.push(`${context}: invalid product object`);
                    return;
                }

                if (!product.id || typeof product.id !== 'string') {
                    errors.push(`${context}: missing id`);
                } else if (seenIds.has(product.id)) {
                    errors.push(`${context}: duplicate id "${product.id}"`);
                } else {
                    seenIds.add(product.id);
                }

                if (!product.name || typeof product.name !== 'string') {
                    errors.push(`${context}: missing name`);
                }

                if (typeof product.price !== 'number' || Number.isNaN(product.price)) {
                    errors.push(`${context}: invalid price`);
                }

                if (!Array.isArray(product.images) || product.images.length === 0) {
                    errors.push(`${context}: images must be a non-empty array`);
                }

                if (typeof product.inStock !== 'boolean') {
                    errors.push(`${context}: inStock must be boolean`);
                }

                if (!product.tags || typeof product.tags !== 'object') {
                    errors.push(`${context}: tags object missing`);
                    return;
                }

                for (const family of REQUIRED_TAXONOMIES) {
                    const tags = product.tags[family];
                    if (!Array.isArray(tags) || tags.length === 0) {
                        errors.push(`${context}: tags.${family} missing or empty`);
                        continue;
                    }

                    for (const tag of tags) {
                        if (!allowedSets[family].has(tag)) {
                            errors.push(`${context}: tags.${family} contains unknown "${tag}"`);
                        }
                    }
                }
            });

            if (errors.length > 0) {
                log(`Catalog validation failed with ${errors.length} issue(s)`, 'error');
                errors.slice(0, 10).forEach((message) => log(`- ${message}`, 'error'));
                if (errors.length > 10) {
                    log(`...and ${errors.length - 10} more issue(s)`, 'error');
                }
                console.error('[WishlizeCatalogValidation]', errors);
                return { ok: false, catalog, taxonomy, errors };
            }

            log(`Catalog validation passed (${catalog.length} products)`, 'info');
            return { ok: true, catalog, taxonomy, errors: [] };
        }

        function buildCrawlerFixture(products, rootId = 'crawler-fixture') {
            const root = document.getElementById(rootId);
            if (!root) {
                return { cards: [], count: 0, error: 'fixture root missing' };
            }

            root.innerHTML = '';
            const sample = products.slice(0, Math.min(products.length, 6));

            sample.forEach((product) => {
                const card = document.createElement('div');
                card.className = 'product-card';
                card.setAttribute('data-product-id', product.id);
                card.style.border = '1px solid #2f3f5f';
                card.style.padding = '8px';
                card.style.margin = '8px 0';
                card.innerHTML = `<strong>${product.name}</strong><br><small>${product.id}</small>`;
                root.appendChild(card);
            });

            return {
                cards: Array.from(root.querySelectorAll('.product-card')),
                count: sample.length,
                products: sample
            };
        }

        function validateShadowCrawler(catalog, taxonomy) {
            if (!window.WishlizeShadowCrawler) {
                log('Shadow crawler missing: window.WishlizeShadowCrawler is not loaded', 'error');
                return;
            }

            const fixture = buildCrawlerFixture(catalog);
            if (fixture.error) {
                log(`Crawler fixture error: ${fixture.error}`, 'error');
                return;
            }

            const hydrationReport = window.WishlizeShadowCrawler.hydrateProductCardTags({
                root: document.getElementById('crawler-fixture'),
                products: catalog
            });

            if (hydrationReport.errors.length > 0) {
                log(`Hydration errors: ${hydrationReport.errors.length}`, 'error');
                hydrationReport.errors.forEach((message) => log(`- ${message}`, 'error'));
                return;
            }

            log(`Hydration passed (${hydrationReport.hydratedCount}/${hydrationReport.cardsFound} cards)`, 'info');

            const crawled = window.WishlizeShadowCrawler.crawlProductTags(
                document.getElementById('crawler-fixture')
            );

            if (crawled.length !== fixture.count) {
                log(`Crawler count mismatch: expected ${fixture.count}, got ${crawled.length}`, 'error');
                return;
            }

            const crawlReport = window.WishlizeShadowCrawler.validateCrawlerOutput({
                crawled,
                products: fixture.products,
                taxonomy
            });

            if (crawlReport.errors.length > 0) {
                log(`Crawler validation failed with ${crawlReport.errors.length} issue(s)`, 'error');
                crawlReport.errors.forEach((message) => log(`- ${message}`, 'error'));
                return;
            }

            if (crawlReport.warnings.length > 0) {
                log(`Crawler validation warnings: ${crawlReport.warnings.length}`, 'warn');
                crawlReport.warnings.slice(0, 6).forEach((message) => log(`- ${message}`, 'warn'));
            }

            log(`Crawler validation passed (${crawled.length} cards extracted)`, 'info');
        }

        function writePhase3Panel(id, value) {
            const panel = document.getElementById(id);
            if (panel) {
                panel.textContent = typeof value === 'string' ? value : pretty(value);
            }
        }

        function getPhase3Context() {
            const audienceSelect = document.getElementById('phase3-audience');
            const audience = audienceSelect ? audienceSelect.value : '';
            return {
                audience: audience || null
            };
        }

        async function runPhase3Recommendation(customPrompt) {
            if (!window.WishlizeMatchingEngine || typeof window.WishlizeMatchingEngine.recommend !== 'function') {
                log('Phase 3 engine missing: window.WishlizeMatchingEngine.recommend is not loaded', 'error');
                return null;
            }

            const promptInput = document.getElementById('phase3-prompt');
            const text = String(customPrompt || (promptInput ? promptInput.value : '') || '');
            const context = getPhase3Context();

            const result = await window.WishlizeMatchingEngine.recommend({
                text,
                context,
                products: window.WishlizeProducts
            });

            writePhase3Panel('phase3-intent-output', result.intent || {});
            writePhase3Panel(
                'phase3-top3-output',
                (result.top3 || []).map((entry) => ({
                    productId: entry.productId,
                    score: entry.score,
                    name: entry.product && entry.product.name,
                    price: entry.product && entry.product.price,
                    breakdown: entry.breakdown
                }))
            );
            writePhase3Panel('phase3-persona-output', result.persona || {});
            writePhase3Panel('phase3-debug-output', result.debug || result.error || {});

            if (result.success) {
                log(`Phase 3 recommendation run complete (${(result.top3 || []).length} picks)`, 'info');
            } else {
                log(`Phase 3 recommendation failed: ${result.error && result.error.code}`, 'error');
            }

            return result;
        }

        async function runPhase3Assertions(catalog) {
            const assertErrors = [];

            if (!window.WishlizeIntentParser || typeof window.WishlizeIntentParser.parse !== 'function') {
                assertErrors.push('Intent parser unavailable');
            }
            if (!window.WishlizeScoring || typeof window.WishlizeScoring.rankProducts !== 'function') {
                assertErrors.push('Scoring engine unavailable');
            }
            if (!window.WishlizePersonas || typeof window.WishlizePersonas.compose !== 'function') {
                assertErrors.push('Personas module unavailable');
            }
            if (!window.WishlizeMatchingEngine || typeof window.WishlizeMatchingEngine.recommend !== 'function') {
                assertErrors.push('Matching engine unavailable');
            }

            if (assertErrors.length > 0) {
                log(`Phase 3 module check failed (${assertErrors.length})`, 'error');
                assertErrors.forEach((message) => log(`- ${message}`, 'error'));
                return;
            }

            const parserCase = window.WishlizeIntentParser.parse('Need a wedding look with classic vibes');
            if (!parserCase.occasion.includes('wedding') || !parserCase.vibe.includes('classic')) {
                assertErrors.push('Parser failed wedding/classic extraction');
            }

            const deterministicOne = await window.WishlizeMatchingEngine.recommend({
                text: 'Need a party look with bold vibe',
                context: { audience: 'men' },
                products: catalog
            });
            const deterministicTwo = await window.WishlizeMatchingEngine.recommend({
                text: 'Need a party look with bold vibe',
                context: { audience: 'men' },
                products: catalog
            });

            const idsOne = (deterministicOne.top3 || []).map((entry) => entry.productId).join('|');
            const idsTwo = (deterministicTwo.top3 || []).map((entry) => entry.productId).join('|');
            if (idsOne !== idsTwo) {
                assertErrors.push('Determinism failed: top3 IDs changed between runs');
            }
            if ((deterministicOne.persona || {}).personaId !== (deterministicTwo.persona || {}).personaId) {
                assertErrors.push('Determinism failed: persona changed between runs');
            }

            const vague = await window.WishlizeMatchingEngine.recommend({
                text: 'asdf qwer zzz',
                context: { audience: null },
                products: catalog
            });
            if (!vague.needsClarification || (vague.top3 || []).length !== 0) {
                assertErrors.push('Clarification flow failed for vague input');
            }

            const stockFixture = catalog.map((product) => {
                if (product.id === 'party-men-1') {
                    return Object.assign({}, product, { inStock: false });
                }
                return product;
            });
            const stockResult = await window.WishlizeMatchingEngine.recommend({
                text: 'party bold for men',
                context: { audience: 'men' },
                products: stockFixture
            });
            const stockIds = (stockResult.top3 || []).map((entry) => entry.productId);
            if (stockIds.includes('party-men-1')) {
                assertErrors.push('Out-of-stock exclusion failed for party-men-1');
            }

            const shapeResult = await window.WishlizeMatchingEngine.recommend({
                text: 'business refined for office',
                context: { audience: 'woman' },
                products: catalog
            });
            if (typeof shapeResult.success !== 'boolean' || !('intent' in shapeResult) || !Array.isArray(shapeResult.top3) || !shapeResult.persona) {
                assertErrors.push('Result contract shape invalid');
            }

            if (assertErrors.length > 0) {
                log(`Phase 3 assertion failed (${assertErrors.length})`, 'error');
                assertErrors.forEach((message) => log(`- ${message}`, 'error'));
                return;
            }

            log('Phase 3 assertions passed', 'info');
        }

        function bindPhase3Harness() {
            const runButton = document.getElementById('phase3-run');
            if (runButton) {
                runButton.addEventListener('click', () => {
                    runPhase3Recommendation();
                });
            }

            const presetButtons = Array.from(document.querySelectorAll('#phase3-presets [data-preset]'));
            presetButtons.forEach((button) => {
                button.addEventListener('click', () => {
                    const promptInput = document.getElementById('phase3-prompt');
                    const audienceInput = document.getElementById('phase3-audience');
                    if (promptInput) {
                        promptInput.value = button.getAttribute('data-preset') || '';
                    }
                    if (audienceInput) {
                        audienceInput.value = button.getAttribute('data-audience') || '';
                    }
                    runPhase3Recommendation();
                });
            });
        }

        async function bootstrapDiagnostics() {
            const catalogCheck = validateConciergeCatalog();
            if (!catalogCheck.ok) {
                return;
            }

            validateShadowCrawler(catalogCheck.catalog, catalogCheck.taxonomy);
            bindPhase3Harness();
            await runPhase3Assertions(catalogCheck.catalog);
            await runPhase3Recommendation();
        }

        bootstrapDiagnostics();
    </script>

    <script src="assets/js/widget-simple.js"></script>
</body>
</html>
